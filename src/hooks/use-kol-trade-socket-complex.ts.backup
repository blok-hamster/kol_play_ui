'use client';

import { useEffect, useState, useCallback, useRef } from 'react';
import { io, Socket } from 'socket.io-client';
import axios from 'axios';
import { useUserStore } from '@/stores/use-user-store';
import { useNotifications } from '@/stores/use-ui-store';
import { PredictionResult } from '@/types';
import { cacheManager } from '@/lib/cache-manager';

export interface KOLTrade {
  id: string;
  kolWallet: string;
  signature: string;
  timestamp: Date;
  tradeData: {
    tokenIn: string;
    tokenOut: string;
    amountIn: number;
    amountOut: number;
    tradeType: 'buy' | 'sell';
    mint?: string;
    dexProgram: string;
    fee?: number;
    name?: string | undefined;
    symbol?: string | undefined;
    image?: string | undefined;
    metadataUri?: string | undefined;
  };
  affectedUsers: string[];
  processed: boolean;
  prediction?: PredictionResult;
}

export interface MindmapUpdate {
  tokenMint: string;
  kolConnections: {
    [kolWallet: string]: {
      kolWallet: string;
      tradeCount: number;
      totalVolume: number;
      lastTradeTime: Date;
      influenceScore: number;
      tradeTypes: string[];
    };
  };
  relatedTokens: string[];
  networkMetrics: {
    centrality: number;
    clustering: number;
    totalTrades: number;
  };
  lastUpdate: Date;
}

type LoadingPhase = 'idle' | 'essential' | 'enhanced' | 'background' | 'complete';

interface ConnectionState {
  isConnected: boolean;
  isConnecting: boolean;
  retryCount: number;
  lastError: string | null;
  connectionHealth: 'healthy' | 'unstable' | 'failed';
}

type DataPriority = 'critical' | 'high' | 'medium' | 'low';

interface UseKOLTradeSocketReturn {
  socket: Socket | null;
  isConnected: boolean;
  recentTrades: KOLTrade[];
  allMindmapData: { [tokenMint: string]: MindmapUpdate };
  trendingTokens: string[];
  isLoadingInitialData: boolean;
  loadingPhase: LoadingPhase;
  connectionState: ConnectionState;
  stats: {
    totalTrades: number;
    uniqueKOLs: number;
    uniqueTokens: number;
    totalVolume: number;
  };
}

export const useKOLTradeSocket = (): UseKOLTradeSocketReturn => {
  const { user } = useUserStore();
  const { showError } = useNotifications();
  
  // Core state
  const [socket, setSocket] = useState<Socket | null>(null);
  const [recentTrades, setRecentTrades] = useState<KOLTrade[]>([]);
  const [allMindmapData, setAllMindmapData] = useState<{
    [tokenMint: string]: MindmapUpdate;
  }>({});
  const [trendingTokens, setTrendingTokens] = useState<string[]>([]);
  const [isLoadingInitialData, setIsLoadingInitialData] = useState(true);
  const [loadingPhase, setLoadingPhase] = useState<LoadingPhase>('idle');
  const [stats, setStats] = useState({
    totalTrades: 0,
    uniqueKOLs: 0,
    uniqueTokens: 0,
    totalVolume: 0,
  });

  const [connectionState, setConnectionState] = useState<ConnectionState>({
    isConnected: false,
    isConnecting: false,
    retryCount: 0,
    lastError: null,
    connectionHealth: 'healthy',
  });

  // Refs for stable references and request management
  const activeRequestsRef = useRef<Map<string, Promise<any>>>(new Map());
  const requestTimestampsRef = useRef<Map<string, number>>(new Map());
  const initializationRef = useRef<{ isInitializing: boolean; hasInitialized: boolean }>({
    isInitializing: false,
    hasInitialized: false
  });

  // Derived state
  const isConnected = connectionState.isConnected;

  // Simple retry with exponential backoff
  const retryWithBackoff = useCallback(
    async <T>(
      operation: () => Promise<T>,
      operationName: string,
      maxRetries: number = 2
    ): Promise<T> => {
      let lastError: Error;
      
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          const result = await operation();
          return result;
        } catch (error) {
          lastError = error as Error;
          
          if (attempt === maxRetries) {
            console.error(`❌ ${operationName} failed after ${maxRetries} retries:`, error);
            break;
          }

          const delay = Math.min(2000 * Math.pow(2, attempt), 10000);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }

      throw lastError!;
    },
    []
  );

  // Mock data for development/fallback
  const getMockData = useCallback((endpoint: string) => {
    if (endpoint.includes('/stats')) {
      return {
        success: true,
        data: {
          tradingStats: {
            totalTrades: 1250,
            uniqueKOLs: 45,
            uniqueTokens: 128,
            totalVolume: 2500000
          }
        }
      };
    }
    
    if (endpoint.includes('/recent')) {
      return {
        success: true,
        data: {
          trades: [
            {
              id: 'mock-1',
              kol_address: 'mock-kol-1',
              token_mint: 'mock-token-1',
              action: 'buy',
              amount: 1000,
              price: 0.5,
              timestamp: new Date().toISOString(),
              kol_name: 'Demo KOL 1',
              token_symbol: 'DEMO1',
              token_name: 'Demo Token 1',
            },
            {
              id: 'mock-2',
              kol_address: 'mock-kol-2',
              token_mint: 'mock-token-2',
              action: 'sell',
              amount: 500,
              price: 1.2,
              timestamp: new Date().toISOString(),
              kol_name: 'Demo KOL 2',
              token_symbol: 'DEMO2',
              token_name: 'Demo Token 2',
            }
          ]
        }
      };
    }
    
    if (endpoint.includes('/trending-tokens')) {
      return {
        success: true,
        data: {
          trendingTokens: [
            { tokenMint: 'mock-token-1' },
            { tokenMint: 'mock-token-2' },
            { tokenMint: 'mock-token-3' }
          ]
        }
      };
    }
    
    return null;
  }, []);

  // Controlled data fetching with strict request management
  const fetchWithPriority = useCallback(
    async <T>(
      url: string,
      options: any = {},
      priority: DataPriority = 'medium',
      cacheKey?: string
    ): Promise<T | null> => {
      // Create a unique request key for deduplication
      const requestKey = `${url}_${priority}`;
      const now = Date.now();
      
      // Check if this exact request is already in progress
      const activeRequest = activeRequestsRef.current.get(requestKey);
      if (activeRequest) {
        console.log(`🔄 Request already in progress for ${requestKey}, waiting...`);
        try {
          return await activeRequest;
        } catch (error) {
          activeRequestsRef.current.delete(requestKey);
          requestTimestampsRef.current.delete(requestKey);
        }
      }

      // Check if we made this request recently (prevent spam)
      const lastRequestTime = requestTimestampsRef.current.get(requestKey);
      if (lastRequestTime && (now - lastRequestTime) < 5000) { // 5 second cooldown
        console.log(`⏳ Request cooldown active for ${requestKey}, using cache...`);
        const cached = cacheKey ? cacheManager.getTradeData(cacheKey) || cacheManager.getStatsData(cacheKey) || cacheManager.getTrendingTokens() : null;
        if (cached) {
          return cached;
        }
      }

      // Check cache first for non-critical requests
      if (cacheKey) {
        const cached = cacheKey ? cacheManager.getTradeData(cacheKey) || cacheManager.getStatsData(cacheKey) || cacheManager.getTrendingTokens() : null;
        if (cached) {
          console.log(`📦 Cache hit for ${cacheKey}`);
          return cached;
        }
      }

      const operation = async (): Promise<T> => {
        // Record request timestamp
        requestTimestampsRef.current.set(requestKey, now);
        
        console.log(`📡 Making single request to ${url} (timeout: 30s)`);
        
        try {
          const response = await axios.get(url, {
            ...options,
            timeout: 30000, // 30 second timeout for slow API
            validateStatus: (status) => status >= 200 && status < 300,
          });

          const data = response.data;
          console.log(`✅ Request successful for ${url} (${JSON.stringify(data).length} bytes)`);

          // Cache successful responses with longer TTL due to slow API
          if (cacheKey && data) {
            const ttl = priority === 'critical' ? 120000 :  // 2 minutes for critical
                       priority === 'high' ? 300000 :       // 5 minutes for high  
                       priority === 'medium' ? 600000 :     // 10 minutes for medium
                       1800000;                              // 30 minutes for low
            // Cache based on cache key type
            if (cacheKey.includes('trades')) {
              cacheManager.setTradeData(cacheKey, data, ttl);
            } else if (cacheKey.includes('stats')) {
              cacheManager.setStatsData(cacheKey, data, ttl);
            } else if (cacheKey.includes('trending')) {
              cacheManager.setTrendingTokens(data, ttl);
            }
          }

          return data;
        } catch (error) {
          // Log the actual error for debugging
          console.warn(`API request failed for ${url}:`, error);
          
          // Try to return mock data as fallback
          const mockData = getMockData(url);
          if (mockData) {
            console.log(`Using mock data for ${url}`);
            return mockData as T;
          }
          
          if (axios.isAxiosError(error)) {
            if (error.response?.status === 403) {
              throw new Error(`Access denied: Authentication required for ${url}`);
            } else if (error.code === 'ERR_NETWORK') {
              throw new Error(`Network error: Unable to connect to ${url}`);
            } else if (error.code === 'ECONNABORTED') {
              throw new Error(`Request timeout: ${url} took too long to respond`);
            } else if (error.response) {
              throw new Error(`HTTP ${error.response.status}: ${error.response.statusText}`);
            }
          }
          throw error;
        }
      };

      // Store the promise to deduplicate concurrent requests
      const requestPromise = retryWithBackoff(operation, `fetch ${url}`, 0); // No retries to prevent overwhelming server
      activeRequestsRef.current.set(requestKey, requestPromise);

      try {
        const result = await requestPromise;
        activeRequestsRef.current.delete(requestKey);
        console.log(`🎯 Request completed successfully for ${requestKey}`);
        return result;
      } catch (error) {
        activeRequestsRef.current.delete(requestKey);
        requestTimestampsRef.current.delete(requestKey);
        
        console.warn(`❌ Request failed for ${url}:`, error);
        
        // Final fallback to mock data
        const mockData = getMockData(url);
        if (mockData) {
          console.log(`🔄 Using mock data fallback for ${url}`);
          return mockData as T;
        }
        
        throw error;
      }
    },
    [retryWithBackoff, getMockData]
  );

  // Phase 1: Load essential data
  const loadEssentialData = useCallback(async (apiUrl: string, headers: Record<string, string>) => {
    setLoadingPhase('essential');

    try {
      // Load cached data first for immediate display
      const cachedTrades = cacheManager.getTradeData('recent');
      const cachedStats = cacheManager.getStatsData('current');
      
      if (cachedTrades) {
        setRecentTrades(cachedTrades);
      }
      
      if (cachedStats) {
        setStats(cachedStats);
      }

      // Fetch fresh essential data in parallel
      const [tradesResponse, statsResponse] = await Promise.allSettled([
        fetchWithPriority<any>(`${apiUrl}/api/kol-trades/recent?limit=50`, { headers }, 'critical', 'recent_trades'),
        fetchWithPriority<any>(`${apiUrl}/api/kol-trades/stats`, { headers }, 'critical', 'current_stats'),
      ]);

      // Process trades response
      if (tradesResponse.status === 'fulfilled' && tradesResponse.value?.success) {
        const tradesData = tradesResponse.value.data?.trades || [];
        if (tradesData.length > 0) {
          setRecentTrades(tradesData);
          cacheManager.setTradeData('recent', tradesData, 300000); // 5 minutes cache
        }
      }

      // Process stats response
      if (statsResponse.status === 'fulfilled' && statsResponse.value?.success) {
        const statsData = statsResponse.value.data?.tradingStats;
        if (statsData) {
          setStats(statsData);
          cacheManager.setStatsData('current', statsData, 600000); // 10 minutes cache
        }
      }

    } catch (error) {
      console.warn('⚠️ Phase 1 using fallback data:', error);
      // Phase 1 errors are handled by the fetchWithPriority fallback
    }
  }, [fetchWithPriority]);

  // Phase 2: Load enhanced data
  const loadEnhancedData = useCallback(async (apiUrl: string, headers: Record<string, string>) => {
    setLoadingPhase('enhanced');

    try {
      const trendingResponse = await fetchWithPriority<any>(
        `${apiUrl}/api/kol-trades/trending-tokens?limit=20`,
        { headers },
        'high',
        'trending_tokens'
      );

      if (trendingResponse?.success && trendingResponse.data?.trendingTokens) {
        const tokens = trendingResponse.data.trendingTokens.map((t: any) => t.tokenMint || t);
        setTrendingTokens(tokens);
        cacheManager.setTrendingTokens(tokens, 900000); // 15 minutes cache
        return tokens;
      }
    } catch (error) {
      console.warn('⚠️ Phase 2 using fallback data:', error);
      // Phase 2 errors are handled by the fetchWithPriority fallback
    }

    return [];
  }, [fetchWithPriority]);

  // Phase 3: Load background data
  const loadBackgroundData = useCallback(async (apiUrl: string, headers: Record<string, string>, tokens: string[]) => {
    setLoadingPhase('background');

    try {
      if (tokens.length === 0) return;

      // Load mindmap data in chunks
      const chunkSize = 10;
      const tokenChunks = [];
      for (let i = 0; i < tokens.length; i += chunkSize) {
        tokenChunks.push(tokens.slice(i, i + chunkSize));
      }

      const mindmapData: { [tokenMint: string]: MindmapUpdate } = {};

      for (let i = 0; i < tokenChunks.length; i++) {
        const chunk = tokenChunks[i];
        
        try {
          const bulkResponse = await fetchWithPriority<any>(
            `${apiUrl}/api/kol-trades/mindmap/bulk`,
            {
              method: 'POST',
              headers: { ...headers, 'Content-Type': 'application/json' },
              data: { tokenMints: chunk },
            },
            'medium',
            `mindmap_bulk_${i}`
          );

          if (bulkResponse?.success && bulkResponse.data?.mindmaps) {
            bulkResponse.data.mindmaps.forEach((mindmap: MindmapUpdate) => {
              mindmapData[mindmap.tokenMint] = mindmap;
              cacheManager.setMindmapData(mindmap.tokenMint, mindmap, 600000);
            });
          }
        } catch (error) {
          console.warn(`⚠️ Phase 3: Mindmap chunk ${i + 1} failed, continuing...`);
        }

        // Add delay between chunks
        if (i < tokenChunks.length - 1) {
          await new Promise(resolve => setTimeout(resolve, 500));
        }
      }

      setAllMindmapData(mindmapData);

    } catch (error) {
      console.warn('⚠️ Phase 3 using fallback data:', error);
      // Phase 3 errors are handled by the fetchWithPriority fallback
    }
  }, [fetchWithPriority]);

  // Main initialization effect
  useEffect(() => {
    let isMounted = true;

    const initializeKOLTradeSocket = async () => {
      // Prevent multiple initializations
      if (initializationRef.current.isInitializing || initializationRef.current.hasInitialized) {
        return;
      }

      initializationRef.current.isInitializing = true;

      try {
        const authToken = typeof window !== 'undefined' ? localStorage.getItem('authToken') : null;
        const apiUrl = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:5000';

        const headers: Record<string, string> = {
          'Content-Type': 'application/json',
        };
        if (authToken) {
          headers['Authorization'] = `Bearer ${authToken}`;
        }

        // Phase 1: Load essential data immediately
        await loadEssentialData(apiUrl, headers);
        if (!isMounted) return;

        // Phase 2: Load enhanced data
        const trendingTokens = await loadEnhancedData(apiUrl, headers);
        if (!isMounted) return;

        // Phase 3: Load background data
        await loadBackgroundData(apiUrl, headers, trendingTokens);
        if (!isMounted) return;

        // Mark initial loading as complete
        setIsLoadingInitialData(false);
        setLoadingPhase('complete');

      } catch (error) {
        console.error('❌ Failed to initialize KOL trade socket:', error);
        if (isMounted) {
          // Don't show error if we have mock data working
          const hasData = recentTrades.length > 0 || Object.keys(allMindmapData).length > 0;
          if (!hasData) {
            showError(
              'Using demo data',
              'Unable to connect to live data. Showing demo data for testing.'
            );
          }
          setIsLoadingInitialData(false);
          setLoadingPhase('complete');
        }
      } finally {
        initializationRef.current.isInitializing = false;
        initializationRef.current.hasInitialized = true;
      }
    };

    initializeKOLTradeSocket();

    return () => {
      isMounted = false;
      
      // Reset initialization state
      initializationRef.current.isInitializing = false;
      initializationRef.current.hasInitialized = false;

      // Clear active requests and timestamps
      activeRequestsRef.current.clear();
      requestTimestampsRef.current.clear();
    };
  }, [loadEssentialData, loadEnhancedData, loadBackgroundData, showError, recentTrades.length, allMindmapData]);

  return {
    socket,
    isConnected,
    recentTrades,
    allMindmapData,
    trendingTokens,
    isLoadingInitialData,
    loadingPhase,
    connectionState,
    stats,
  };
};
